/*
Copyright (c) 2015, salesforce.com, inc. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
Neither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('lodash');
var invariant = require('invariant');

/*
 * @typedef {object} Node
 * @property {string} type
 * @property {string|array} value
 * @property {InputStream~Position} start
 * @property {InputStream~Position} next
 */

/**
 * Convert a @{link TokenStreamProxy} to a @{link Node}
 *
 * @protected
 * @class
 */

var Parser = function () {
  /**
   * Create a new InputStream
   *
   * @param {TokenStreamProxy} tokens
   */

  function Parser(tokens) {
    _classCallCheck(this, Parser);

    this.tokens = tokens;
  }
  /**
   * Return a new @{link Node}
   *
   * @private
   * @param {string} type
   * @param {string|array} value
   * @param {InputStream~Position} start
   * @param {InputStream~Position} next
   * @returns {Node}
   */


  _createClass(Parser, [{
    key: 'createNode',
    value: function createNode(type, value, start, next) {
      return { type: type, value: value, start: start, next: next };
    }
    /**
     * Return true if the current token(s) are of the provided type
     * and optionally match the specific character(s)
     *
     * @private
     * @param {string} type
     * @param {...string} values
     * @returns {boolean}
     */

  }, {
    key: 'is_type',
    value: function is_type(type) {
      var _this = this;

      var t = this.tokens.peek();

      for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      if (!values.length) return t ? type.test(t.type) : false;
      return values.reduce(function (a, c, i) {
        var t = _this.tokens.peek(i);
        return !t ? false : a && type.test(t.type) && t.value === c;
      }, true);
    }
    /**
     * Return true if the current token is a space
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_space',
    value: function is_space() {
      return this.is_type(/space/);
    }
    /**
     * Return true if the current token is a comment
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_comment',
    value: function is_comment() {
      return this.is_type(/comment/);
    }
    /**
     * Return true if the current token is a punctuation
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_punctuation',
    value: function is_punctuation() {
      return this.is_type.apply(this, [/punctuation/].concat(Array.prototype.slice.call(arguments)));
    }
    /**
     * Return true if the current token is an operator
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_operator',
    value: function is_operator() {
      return this.is_type.apply(this, [/operator/].concat(Array.prototype.slice.call(arguments)));
    }
    /**
     * Return true if the current token is an identifier
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_identifier',
    value: function is_identifier() {
      return this.is_type.apply(this, [/identifier/].concat(Array.prototype.slice.call(arguments)));
    }
    /**
     * Return true if the current token is an atkeyword
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_atkeyword',
    value: function is_atkeyword() {
      return this.is_type.apply(this, [/atkeyword/].concat(Array.prototype.slice.call(arguments)));
    }
    /**
     * Return true if the current tokens are interpolation
     *
     * @private
     * @returns {boolean}
     */

  }, {
    key: 'is_interpolation',
    value: function is_interpolation() {
      return this.is_punctuation('#', '{');
    }
    /**
     * Return the current and next token if the isType predicate succeeds
     *
     * @private
     * @param {string} type
     * @param {function} isType
     * @param {...string} chars
     * @throws Error
     * @returns {boolean}
     */

  }, {
    key: 'skip_type',
    value: function skip_type(type, isType) {
      for (var _len2 = arguments.length, chars = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        chars[_key2 - 2] = arguments[_key2];
      }

      if (isType.apply(this, chars)) {
        return { start: this.tokens.peek(), next: this.tokens.next() };
      } else {
        this.tokens.err('Expecting ' + type + ': "' + chars.join('') + '"');
      }
    }
    /**
     * Expect a punctuation token optionally of the specified type
     *
     * @private
     * @param (...string) chars
     * @throws Error
     * @returns {boolean}
     */

  }, {
    key: 'skip_punctuation',
    value: function skip_punctuation() {
      return this.skip_type.apply(this, ['punctuation', this.is_punctuation].concat(Array.prototype.slice.call(arguments)));
    }
    /**
     * Expect an operator token optionally of the specified type
     *
     * @private
     * @param (...string) chars
     * @throws Error
     * @returns {boolean}
     */

  }, {
    key: 'skip_operator',
    value: function skip_operator() {
      return this.skip_type.apply(this, ['operator', this.is_operator].concat(Array.prototype.slice.call(arguments)));
    }
    /**
     * Expect an atkeyword token
     *
     * @private
     * @throws Error
     * @returns {boolean}
     */

  }, {
    key: 'skip_atkeyword',
    value: function skip_atkeyword() {
      return this.skip_type('atkeyword', this.is_atkeyword);
    }
    /**
     * Throw an error at the current token
     *
     * @private
     * @throws Error
     */

  }, {
    key: 'unexpected',
    value: function unexpected() {
      this.tokens.err('Unexpected token: "' + JSON.stringify(this.input.peek()) + '"');
    }
    /**
     * Return a top level stylesheet Node
     *
     * @public
     * @returns {Node}
     */

  }, {
    key: 'parse_stylesheet',
    value: function parse_stylesheet() {
      var value = [];
      while (!this.tokens.eof()) {
        var node = this.parse_node();
        if (_.isArray(node)) {
          value.push.apply(value, _toConsumableArray(node));
        } else {
          value.push(node);
        }
      }
      return this.createNode('stylesheet', value);
    }
    /**
     * Parse a top-level Node (atrule,rule,declaration,comment,space)
     *
     * @private
     * @returns {Node|Node[]}
     */

  }, {
    key: 'parse_node',
    value: function parse_node() {
      var _this2 = this;

      if (this.is_space() || this.is_comment()) return this.tokens.next();

      var value = [];

      var maybe_declaration = function maybe_declaration(punctuation) {
        var expandedPseudo = false;
        // If the declaration ends with a ";" expand the first pseudo_class
        // because pseudo_class can't be part of a declaration property
        if (punctuation === ';') {
          var pseudoIndex = _.findIndex(value, {
            type: 'pseudo_class'
          });
          if (pseudoIndex > 0) {
            var a = value[pseudoIndex];
            var b = _this2.createNode('punctuation', ':', a.start, _.first(a.value).start);
            var nodes = [b].concat(a.value);
            value.splice.apply(value, [pseudoIndex, 1].concat(_toConsumableArray(nodes)));
            expandedPseudo = true;
          }
        }
        // Try to find a ":"
        var puncIndex = _.findIndex(value, {
          type: 'punctuation',
          value: ':'
        });
        // If we found a ":"
        if (puncIndex >= 0) {
          var maybeSpace = value[puncIndex + 1];
          // If we found a space, it wasn't a pseudo class selector,
          // so parse it as a declaration
          // http://www.sassmeister.com/gist/0e60f53033a44b9e5d99362621143059
          if (maybeSpace.type === 'space' || expandedPseudo) {
            var start = _.first(value).start;
            var next = _.last(value).next;
            var property_ = _.take(value, puncIndex);
            var propertyNode = _this2.createNode('property', property_, _.first(property_).start, _.last(property_).next);
            var value_ = _.drop(value, puncIndex + 1);
            if (punctuation === '{') {
              var block = _this2.parse_block();
              value_.push(block);
              next = block.next;
            }
            var valueNode = _this2.createNode('value', value_, _.first(value_).start, _.last(value_).next);
            var declarationValue = [propertyNode, value[puncIndex], valueNode];
            if (punctuation === ';') {
              var _skip_punctuation = _this2.skip_punctuation(';');

              var _start2 = _skip_punctuation.start;
              var _next = _skip_punctuation.next;

              declarationValue.push(_start2);
              _next = _next.start;
            }
            return _this2.createNode('declaration', declarationValue, start, next);
          }
        }
        return false;
      };

      while (!this.tokens.eof()) {
        // AtRule
        if (this.is_atkeyword()) {
          return value.concat(this.parse_at_rule());
        }
        // Atom
        value.push(this.parse_atom());
        // Rule
        if (this.is_punctuation('{')) {
          if (value.length) {
            return maybe_declaration('{') || this.parse_rule(value);
          } else {
            // TODO: throw error?
            return value.concat(this.parse_block());
          }
        }
        // Declaration
        if (this.is_punctuation(';')) {
          return maybe_declaration(';');
        }
      }
      return value;
    }
    /**
     * Parse as many atoms as possible while the predicate is true
     *
     * @private
     * @param {function} predicate
     * @returns {Node[]}
     */

  }, {
    key: 'parse_expression',
    value: function parse_expression(predicate) {
      var value = [];
      var declaration = [];
      while (true) {
        if (this.tokens.eof() || !predicate()) break;
        // Declaration
        if (this.is_punctuation(':') && declaration.length) {
          value.push(this.parse_declaration(declaration));
          // Remove the items that are now a declaration
          value = _.xor(value, declaration);
          declaration = [];
        }
        // Atom
        if (this.tokens.eof() || !predicate()) break;
        var atom = this.parse_atom();
        value.push(atom);
        // Collect items that might be parsed as a declaration
        // $map: ("red": "blue", "hello": "world");
        switch (atom.type) {
          case 'space':
          case 'punctuation':
            break;
          default:
            declaration.push(atom);
        }
      }
      return value;
    }
    /**
     * Parse a single atom
     *
     * @private
     * @returns {Node}
     */

  }, {
    key: 'parse_atom',
    value: function parse_atom() {
      var _this3 = this;

      return this.maybe_function(function () {
        // Parens
        if (_this3.is_punctuation('(')) {
          return _this3.parse_wrapped('parentheses', '(', ')');
        }
        // Interpolation
        if (_this3.is_interpolation()) {
          return _this3.parse_interolation();
        }
        // Attr
        if (_this3.is_punctuation('[')) {
          return _this3.parse_wrapped('attribute', '[', ']');
        }
        // Class
        if (_this3.is_punctuation('.')) {
          return _this3.parse_selector('class', '.');
        }
        // Id
        if (_this3.is_punctuation('#')) {
          return _this3.parse_selector('id', '#');
        }
        // Pseudo Element
        if (_this3.is_punctuation('::')) {
          return _this3.parse_selector('pseudo_element', ':');
        }
        // Pseudo Class
        if (_this3.is_punctuation(':')) {
          var next = _this3.tokens.peek(1);
          if (next.type === 'identifier' || next.type === 'punctuation' && next.value === '#') {
            return _this3.parse_selector('pseudo_class', ':');
          }
        }
        // Token
        return _this3.tokens.next();
      });
    }
    /**
     * Parse a declaration
     *
     * @private
     * @param {Node[]} property
     * @returns {Node}
     */

  }, {
    key: 'parse_declaration',
    value: function parse_declaration(property) {
      var _this4 = this;

      var _skip_punctuation2 = this.skip_punctuation(':');

      var firstSeparator = _skip_punctuation2.start;
      // Expression

      var secondSeparator = void 0;
      var value = this.parse_expression(function () {
        if (_this4.is_punctuation(';')) {
          secondSeparator = _this4.tokens.next();
          return false;
        }
        if (_this4.is_punctuation(',')) {
          secondSeparator = _this4.tokens.next();
          return false;
        }
        if (_this4.is_punctuation(')')) return false;
        return true;
      });
      var propertyNode = this.createNode('property', property, _.first(property).start, _.last(property).next);
      var valueNode = this.createNode('value', value, _.first(value).start, _.last(value).next);
      var declarationValue = [propertyNode, firstSeparator, valueNode];
      if (secondSeparator) declarationValue.push(secondSeparator);
      return this.createNode('declaration', declarationValue, _.first(property).start, _.last(value).next);
    }
    /**
     * Parse an expression wrapped in the provided chracters
     *
     * @private
     * @param {string} type
     * @param {string} open
     * @param {string} close
     * @param {InputToken~Position} start
     * @returns {Node}
     */

  }, {
    key: 'parse_wrapped',
    value: function parse_wrapped(type, open, close, _start) {
      var _this5 = this;

      var _skip_punctuation3 = this.skip_punctuation(open);

      var start = _skip_punctuation3.start;

      var value = this.parse_expression(function () {
        return !_this5.is_punctuation(close);
      });

      var _skip_punctuation4 = this.skip_punctuation(close);

      var next = _skip_punctuation4.next;

      return this.createNode(type, value, (_start || start).start, next.next);
    }
    /**
     * Parse Nodes wrapped in "{}"
     *
     * @private
     * @returns {Node}
     */

  }, {
    key: 'parse_block',
    value: function parse_block() {
      var _skip_punctuation5 = this.skip_punctuation('{');

      var start = _skip_punctuation5.start;

      var value = [];
      while (!this.tokens.eof() && !this.is_punctuation('}')) {
        var node = this.parse_node();
        if (_.isArray(node)) {
          value.push.apply(value, _toConsumableArray(node));
        } else {
          value.push(node);
        }
      }

      var _skip_punctuation6 = this.skip_punctuation('}');

      var next = _skip_punctuation6.next;
      // Sass allows blocks to end with semicolons

      if (this.is_punctuation(';')) {
        this.skip_punctuation(';');
      }
      return this.createNode('block', value, start.start, next.next);
    }
    /**
     * Parse comma separated expressions wrapped in "()"
     *
     * @private
     * @param {string} [type] the type attrribute of the caller
     * @returns {Node}
     */

  }, {
    key: 'parse_arguments',
    value: function parse_arguments(type) {
      var _this6 = this;

      var _skip_punctuation7 = this.skip_punctuation('(');

      var start = _skip_punctuation7.start;

      var value = [];
      if (type === 'pseudo_class') {
        while (!this.tokens.eof() && !this.is_punctuation(')')) {
          value.push(this.parse_atom());
        }
      } else {
        while (!this.tokens.eof() && !this.is_punctuation(')')) {
          value = value.concat(this.parse_expression(function () {
            if (_this6.is_punctuation(',')) return false;
            if (_this6.is_punctuation(')')) return false;
            return true;
          }));
          if (this.is_punctuation(',')) {
            value.push(this.tokens.next());
          }
        }
      }

      var _skip_punctuation8 = this.skip_punctuation(')');

      var next = _skip_punctuation8.next;

      return this.createNode('arguments', value, start.start, next.next);
    }
    /**
     * Optionally wrap a node in a "function"
     *
     * @private
     * @param {function} node - returns a node to optionally be wrapped
     * @returns {Node}
     */

  }, {
    key: 'maybe_function',
    value: function maybe_function(node) {
      node = node();
      var types = ['identifier', 'function', 'interpolation', 'pseudo_class'];
      return this.is_punctuation('(') && _.includes(types, node.type) ? this.parse_function(node) : node;
    }
    /**
     * Parse a function node
     *
     * @private
     * @params {Node} node - the node to wrap (usually an identifier)
     * @returns {Node}
     */

  }, {
    key: 'parse_function',
    value: function parse_function(node) {
      var args = this.parse_arguments(node.type);
      return this.createNode('function', [node, args], node.start, args.next);
    }
    /**
     * Parse interpolation
     *
     * @private
     * @returns {Node}
     */

  }, {
    key: 'parse_interolation',
    value: function parse_interolation() {
      var _skip_punctuation9 = this.skip_punctuation('#');

      var start = _skip_punctuation9.start;

      return this.parse_wrapped('interpolation', '{', '}', start);
    }
    /**
     * Parse an atrule
     *
     * @private
     * @returns {Node}
     */

  }, {
    key: 'parse_at_rule',
    value: function parse_at_rule() {
      var _skip_atkeyword = this.skip_atkeyword();

      var start = _skip_atkeyword.start;

      var value = [start];
      // Space
      if (this.is_space()) value.push(this.tokens.next());
      // Identifier (prevent args being converted to a "function")
      if (this.is_identifier()) value.push(this.tokens.next());
      // Go
      while (!this.tokens.eof()) {
        if (this.is_punctuation('(') && /mixin|include|function/.test(start.value)) {
          value.push(this.parse_arguments());
        }
        if (this.is_punctuation('{')) {
          value.push(this.parse_block());
          break;
        }
        if (this.is_punctuation(';')) {
          value.push(this.tokens.next());
          break;
        } else {
          value.push(this.parse_atom());
        }
      }
      return this.createNode('atrule', value, start.start, _.last(value).next);
    }
    /**
     * Parse a rule
     *
     * @private
     * @param {Node[]} selectors
     * @returns {Node}
     */

  }, {
    key: 'parse_rule',
    value: function parse_rule(selectors) {
      var selector = this.createNode('selector', selectors, _.first(selectors).start, _.last(selectors).next);
      var block = this.parse_block();
      return this.createNode('rule', [selector, block], selector.start, block.next);
    }
    /**
     * Parse selector starting with the provided punctuation
     *
     * @private
     * @param {string} type
     * @param {string} punctuation
     * @returns {Node}
     */

  }, {
    key: 'parse_selector',
    value: function parse_selector(type, punctuation) {
      var _skip_punctuation10 = this.skip_punctuation(punctuation);

      var start = _skip_punctuation10.start;
      // Pseudo Element

      if (this.is_punctuation(':')) {
        this.skip_punctuation(':');
      }
      var value = [];
      var next = this.is_interpolation() ? this.parse_interolation() : this.tokens.next();
      // Selectors can be a combination of identifiers and interpolation
      while (next.type === 'identifier' || next.type === 'interpolation' || next.type === 'operator') {
        value.push(next);
        next = this.is_interpolation() ? this.parse_interolation() : this.tokens.peek();
        if (!next) break;
        if (next.type === 'identifier') this.tokens.next();
        // This is usually a dash following interpolation because identifiers
        // can't start with a dash
        if (next.type === 'operator') this.tokens.next();
      }
      if (!value.length) {
        this.tokens.err('Selector ("' + type + '") expected "identifier" or "interpolation"');
      }
      return this.createNode(type, value, start.start, _.last(value).next);
    }
  }]);

  return Parser;
}();

/**
 * @function parseTokenStream
 * @private
 * @param {TokenStreamProxt} tokenStream
 * @returns {TokenStreamProxy}
 */


module.exports = function (tokenStream) {
  invariant(_.isPlainObject(tokenStream) && _.has(tokenStream, 'next'), 'Parser requires a TokenStream');
  var parser = new Parser(tokenStream);
  return parser.parse_stylesheet();
};
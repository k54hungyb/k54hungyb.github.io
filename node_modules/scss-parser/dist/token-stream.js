/*
Copyright (c) 2015, salesforce.com, inc. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
Neither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _ = require('lodash');
var invariant = require('invariant');

var HEX_PATTERN = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/;

/**
 * Takes a predicate function and returns its inverse
 *
 * @private
 * @param {function} p
 * @returns {function}
 */
var not = function not(p) {
  return function (c) {
    return !p(c);
  };
};

/**
 * Return a function that matches the provided character
 *
 * @private
 * @param {function} c
 * @returns {function}
 */
var is_char = function is_char(c) {
  return function (cc) {
    return c === cc;
  };
};

/**
 * Return true if the character matches whitespace
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_whitespace = function is_whitespace(c) {
  return '\t\n '.indexOf(c) >= 0;
};

/**
 * Return true if the character matches a newline
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_newline = function is_newline(c) {
  return c === '\n';
};

/**
 * Return true if the character matches an operator
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_operator = function is_operator(c) {
  return '+-*/%=&|!~><^'.indexOf(c) >= 0;
};

/**
 * Return true if the provided operated can be repeated
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_operator_repeatable = function is_operator_repeatable(c) {
  return '&|='.indexOf(c) >= 0;
};

/**
 * Return true if the character matches a punctuation
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_punctuation = function is_punctuation(c) {
  return ',;(){}[]:#.'.indexOf(c) >= 0;
};

/**
 * Return true if the character matches a digit
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_digit = function is_digit(c) {
  return (/[0-9]/i.test(c)
  );
};

/**
 * Return true if input matches a comment
 *
 * @private
 * @param {InputStreamProxt} input
 * @returns {boolean}
 */
var is_comment_start = function is_comment_start(input) {
  return input.peek() === '/' && (input.peek(1) === '/' || input.peek(1) === '*');
};

/**
 * Return true if the character matches the start of an identifier
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_ident_start = function is_ident_start(c) {
  return (/[a-z_]/i.test(c)
  );
};

/**
 * Return true if the character matches an identifier
 *
 * @private
 * @param {string} c
 * @returns {boolean}
 */
var is_ident = function is_ident(c) {
  return (/[a-z0-9_-]/i.test(c)
  );
};

/**
 * Return true if input matches the start of a number
 *
 * @private
 * @param {InputStreamProxt} input
 * @returns {boolean}
 */
var is_number_start = function is_number_start(input) {
  return is_digit(input.peek()) || input.peek() === '.' && is_digit(input.peek(1));
};

/**
 * Return the length of a possible hex color
 *
 * @private
 * @param {InputStreamProxt} input
 * @returns {number|boolean}
 */
var is_hex = function is_hex(input) {
  var hex = input.peek();
  if (hex === '#') {
    var _3 = false;
    var _6 = false;
    while (hex.length < 7) {
      var c = input.peek(hex.length);
      if (_.isEmpty(c)) break;
      hex += c;
      if (hex.length === 4) _3 = HEX_PATTERN.test(hex);
      if (hex.length === 7) _6 = HEX_PATTERN.test(hex);
    }
    return _6 ? 6 : _3 ? 3 : false;
  }
  return false;
};

/*
 * @typedef {object} Token
 * @property {string} type
 * @property {string|array} value
 * @property {InputStream~Position} start
 * @property {InputStream~Position} next
 */

/**
 * Yield tokens from an {@link InputStream}
 *
 * @protected
 * @class
 */

var TokenStream = function () {
  /**
   * Create a new InputStream
   *
   * @param {InputStreamProxy} input
   */

  function TokenStream(input) {
    _classCallCheck(this, TokenStream);

    invariant(_.isPlainObject(input) && _.has(input, 'next'), 'TokenStream requires an InputStream');
    this.input = input;
    this.tokens = [];
  }
  /**
   * Return a new @{link Token}
   *
   * @private
   * @param {string} type
   * @param {string|array} value
   * @param {InputStream~Position} start
   * @returns {Token}
   */


  _createClass(TokenStream, [{
    key: 'createToken',
    value: function createToken(type, value, start) {
      return Object.freeze({
        type: type,
        value: value,
        start: start,
        next: this.input.position()
      });
    }
    /**
     * Return the current token with an optional offset
     *
     * @public
     * @param {number} offset
     * @returns {Token}
     */

  }, {
    key: 'peek',
    value: function peek(offset) {
      if (!this.tokens.length) {
        var token = this.read_next();
        if (token) this.tokens.push(token);
      }
      if (!offset) return this.tokens[0];
      if (offset < this.tokens.length) return this.tokens[offset];
      while (this.tokens.length <= offset) {
        var _token = this.read_next();
        if (_token) this.tokens.push(_token);else break;
      }
      return this.tokens[offset];
    }
    /**
     * Return the current token and advance the TokenStream
     *
     * @public
     * @returns {Token}
     */

  }, {
    key: 'next',
    value: function next() {
      var token = this.tokens.shift();
      return token || this.read_next();
    }
    /**
     * Return true if the stream has reached the end
     *
     * @public
     * @returns {boolean}
     */

  }, {
    key: 'eof',
    value: function eof() {
      return typeof this.peek() === 'undefined';
    }
    /**
     * Throw an error at the current line/column
     *
     * @public
     * @param {string} message
     * @throws Error
     */

  }, {
    key: 'err',
    value: function err() {
      var _input;

      return (_input = this.input).err.apply(_input, arguments);
    }
    /**
     * Parse the next character(s) as a Token
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_next',
    value: function read_next() {
      if (this.input.eof()) return null;
      var c = this.input.peek();
      // Whitespace
      if (is_whitespace(c)) {
        return this.read_whitespace();
      }
      // Comments
      if (is_comment_start(this.input)) {
        return this.read_comment();
      }
      // Number
      if (is_number_start(this.input)) {
        return this.read_number();
      }
      // Hex
      var hex_length = is_hex(this.input);
      if (hex_length) {
        return this.read_hex(hex_length);
      }
      // Punctutation
      if (is_punctuation(c)) {
        return this.read_punctuation();
      }
      // Identifier
      if (is_ident_start(c)) {
        return this.read_ident();
      }
      // Operator
      if (is_operator(c)) {
        return this.read_operator();
      }
      // String
      if (c === '"' || c === '\'') {
        return this.read_string(c);
      }
      // @ keyword
      if (c === '@') {
        return this.read_atkeyword();
      }
      // Variable
      if (c === '$') {
        return this.read_variable();
      }
      this.err('Can\'t handle character: "' + c + '"');
    }
    /**
     * Advance the input while the prediciate is true
     *
     * @private
     * @param {function} predicate
     * @returns {string}
     */

  }, {
    key: 'read_while',
    value: function read_while(predicate) {
      var s = '';
      while (!this.input.eof() && predicate(this.input.peek())) {
        s += this.input.next();
      }
      return s;
    }
    /**
     * Advance the input (consuming escaped characters) until the end character
     * is reached
     *
     * @private
     * @param {string} end
     * @returns {string}
     */

  }, {
    key: 'read_escaped',
    value: function read_escaped(end) {
      var escaped = false;
      var str = '';
      this.input.next();
      while (!this.input.eof()) {
        var c = this.input.next();
        if (escaped) {
          str += c;
          escaped = false;
        } else if (c === '\\') {
          str += c;
          escaped = true;
        } else if (c === end) {
          break;
        } else {
          str += c;
        }
      }
      return str;
    }
    /**
     * Advance the input while whitespace characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_whitespace',
    value: function read_whitespace() {
      var start = this.input.position();
      var value = this.read_while(is_whitespace);
      return this.createToken('space', value, start);
    }
    /**
     * Advance the input while comment characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_comment',
    value: function read_comment() {
      var start = this.input.position();
      this.input.next();
      switch (this.input.next()) {
        case '/':
          return this.read_comment_single(start);
        case '*':
          return this.read_comment_multi(start);
      }
    }
    /**
     * Advance the input while singleline comment characters are matched
     *
     * @private
     * @params {InputStream~Position} start
     * @returns {Token}
     */

  }, {
    key: 'read_comment_single',
    value: function read_comment_single(start) {
      var value = this.read_while(not(is_newline));
      return this.createToken('comment_singleline', value, start);
    }
    /**
     * Advance the input while multiline comment characters are matched
     *
     * @private
     * @params {InputStream~Position} start
     * @returns {Token}
     */

  }, {
    key: 'read_comment_multi',
    value: function read_comment_multi(start) {
      var prev = '';
      var value = '';
      while (!this.input.eof()) {
        var next = this.input.next();
        if (next === '/' && prev === '*') break;
        value += prev;
        prev = next;
      }
      return this.createToken('comment_multiline', value, start);
    }
    /**
     * Advance the input while punctuation characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_punctuation',
    value: function read_punctuation() {
      var start = this.input.position();
      var value = this.input.next();
      return this.createToken('punctuation', value, start);
    }
    /**
     * Advance the input while operators characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_operator',
    value: function read_operator() {
      var start = this.input.position();
      var c = this.input.peek();
      var value = is_operator_repeatable(c) ? this.read_while(is_char(c)) : this.input.next();
      return this.createToken('operator', value, start);
    }
    /**
     * Advance the input while identifier characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_ident',
    value: function read_ident() {
      var start = this.input.position();
      var value = this.read_while(is_ident);
      return this.createToken('identifier', value, start);
    }
    /**
     * Advance the input while string characters are matched
     *
     * @private
     * @param {string} c - " or '
     * @returns {Token}
     */

  }, {
    key: 'read_string',
    value: function read_string(c) {
      var start = this.input.position();
      var value = this.read_escaped(c);
      var type = 'string';
      if (c === '"') type = 'string_double';
      if (c === '\'') type = 'string_single';
      return this.createToken(type, value, start);
    }
    /**
     * Advance the input while number characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_number',
    value: function read_number() {
      var start = this.input.position();
      var hasPoint = false;
      var value = this.read_while(function (c) {
        if (c === '.') {
          if (hasPoint) return false;
          hasPoint = true;
          return true;
        }
        return is_digit(c);
      });
      return this.createToken('number', value, start);
    }
    /**
     * Advance the input while hex characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_hex',
    value: function read_hex(length) {
      var start = this.input.position();
      this.input.next();
      var value = '';
      for (var i = 0; i < length; i++) {
        value += this.input.next();
      }
      return this.createToken('color_hex', value, start);
    }
    /**
     * Advance the input while atkeyword characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_atkeyword',
    value: function read_atkeyword() {
      var start = this.input.position();
      this.input.next();
      var value = this.read_while(is_ident);
      return this.createToken('atkeyword', value, start);
    }
    /**
     * Advance the input while variable characters are matched
     *
     * @private
     * @returns {Token}
     */

  }, {
    key: 'read_variable',
    value: function read_variable() {
      var start = this.input.position();
      this.input.next();
      var value = this.read_while(is_ident);
      return this.createToken('variable', value, start);
    }
  }]);

  return TokenStream;
}();

/**
 * @function createTokenStream
 * @private
 * @param {InputStreamProxy} input
 * @returns {TokenStreamProxy}
 */


module.exports = function (input) {
  var t = new TokenStream(input);
  /**
   * @namespace
   * @borrows TokenStream#peek as #peek
   * @borrows TokenStream#next as #next
   * @borrows TokenStream#eof as #eof
   * @borrows TokenStream#err as #err
   */
  var TokenStreamProxy = {
    peek: function peek() {
      return t.peek.apply(t, arguments);
    },
    next: function next() {
      return t.next();
    },
    eof: function eof() {
      return t.eof();
    },
    err: function err() {
      return t.err.apply(t, arguments);
    },

    /**
     * Yield all tokens from the stream
     *
     * @instance
     * @returns {Token[]}
     */
    all: function all() {
      var tokens = [];
      while (!t.eof()) {
        tokens.push(t.next());
      }return tokens;
    }
  };
  return TokenStreamProxy;
};